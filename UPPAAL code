/**************************************
Constants
**************************************/
const int nodeMax = 3;
const int roundMax = 25;
const int blockMax = 25;
const int mineMax = 3;    // Most blocks adversary can mine at once
const int maxLatency = 6; // Longest time an adversary can withhold a block (in rounds)

/**************************************
Channels
**************************************/
chan end_game;

/**************************************
User Defined Objects
**************************************/
typedef struct
{
    int[0,nodeMax] id; 
	int[1,roundMax] rd; 
	
	int parent;    // "Pointer" to index of previous block in the blockchain array
	int blocknum;  
	int length;    
	
    bool sent[nodeMax]; // Used to stop adversary from sending blocks multiple times

} Block;

typedef struct 
{
	Block BlockChain[blockMax]; // Global structure of all blocks
	int bestBlock[nodeMax];     // Head of each honest parties chain
} Ledger;


/**************************************
Variables
**************************************/
// Shared data structures
Block b1;
Ledger GlobalLedger;

// Used to bound run of model 
int[1,blockMax] current_block;
int current_round = 1;

int incoming; // Index of block sent to honest party
int win_streak; // count of how many blocks the adversary has mined in a row


int Overdue_Blocks[blockMax]; // Blocks that have been kept too long and must be sent
int Candidate_Blocks[blockMax];  // Blocks that honest parties would accept as their best chain (based on length)

/**************************************
This function creates an adverserial 
block.
**************************************/
void initAdvBlock(Block & b)
{
    b.id = 0;
    b.rd = current_round;

    b.parent = 1;                 //Have to figure out how to non-deterministically choose parent
    b.blocknum = current_block;
    b.length = 1;

    b.sent[0] = false;
    b.sent[1] = false;
    b.sent[2] = false;
}

/**************************************
This function creates an honest block.
**************************************/
void HonestBlock(int miner, Block & b)
{
    b.id = miner;
    b.rd = current_round;

    b.parent = GlobalLedger.bestBlock[miner]; // Mine on top of the honest parties best chain
    b.blocknum = current_block;
    b.length = (GlobalLedger.BlockChain[b.parent].length) + 1; // Length should be one longer than the parent

    b.sent[0] = false;
    b.sent[1] = false;
    b.sent[2] = false;
}

/**************************************
This function adds new blocks to the 
global blockchain
**************************************/
void addBlock(Block &b)
{
    GlobalLedger.BlockChain[current_block] = b;
    current_block++;
}

/**************************************
This function checks whether an id is the
'sent' field of a given block in the chain.
This prevents the model from sending the 
same block to a node multiple times.
**************************************/
bool findBlock(int blockIndex, int id)
{
 
    
    for(i : int[0, nodeMax-1] )  // For all indices in the 'sent' field, check for the id of a given party 
            if(GlobalLedger.BlockChain[blockIndex].sent[i] == id)
                return true;
        
    return false;
}

/**************************************
This function handles the communication
aspect of the network. It makes the
adversary send overdue and candidate
blocks to the honest parties
**************************************/
void sendBlock()
{
    int[0, blockMax-1] k = 0; //Overdue block counter
    int[0, blockMax-1] l = 0; //Candidate block counter

    for(i : int[0, nodeMax-1] ) // For all honest parties
        for(j : int[0, blockMax-1] ) // Can probably change this to "current_block-1"
        {
            if( (GlobalLedger.BlockChain[j].rd > current_round + maxLatency ) && !findBlock(j, i)) // If the block is overdue and it hasnt been seen by the honest party
                {
                    Overdue_Blocks[k] = j; // This might have to be a 2-d array
                    k++;
 
                }
            if( (GlobalLedger.BlockChain[j].length >  GlobalLedger.BlockChain[GlobalLedger.bestBlock[i]].length) ) // If the block is longer than the best the honest party  has
                {

                }    
        }
}
